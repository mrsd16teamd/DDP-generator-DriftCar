double x_ = x[0];
double y_ = x[1];
double phi = x[2];
double Ux = x[3];
double Uy = x[4];
double r = x[5];
double thr = u[0];
double steer = u[1];
//     printf("x_: %f, y_: %f, phi: %f, Ux: %f, Uy: %f, r: %f\n", x_, y_, phi, Ux, Uy, r);
//     printf("thr: %f, steer: %f\n", thr, steer);
double G_f = p[0][0];
double G_r = p[1][0];
double Iz = p[2][0];
double a = p[4][0];
double b = p[5][0];
double c_a = p[6][0];
double c_x = p[7][0];
double m = p[20][0];
double mu = p[21][0];
double mu_s = p[22][0];

double pi = 3.141592653589793;

double alpha_F;
double alpha_R;

if(Ux >= 0.0) {
    alpha_F = atan((Uy+a*r)/(abs(Ux)+1e-3))-steer; 
} else {
    alpha_F = atan((Uy+a*r)/(abs(Ux)+1e-3))+steer;
}
alpha_R = atan((Uy-b*r)/(abs(Ux)+1e-3));

double K = (thr-Ux)/(abs(Ux)+1e-3);
double reverse = 1.0;

if(K<0.0){
    reverse = -1.0; 
    K = abs(K);
}

if(abs(alpha_F)>pi/2.0) {
 alpha_F = (pi-abs(alpha_F))*(alpha_F/abs(alpha_F));
}

//     printf("K: %f, alpha_F: %f, alpha_R: %f\n", K, alpha_F, alpha_R);

double gamma_F = sqrt(pow(c_a,2.0)*pow(tan(alpha_F),2.0));
double gamma_R = sqrt(pow(c_x,2.0)*pow((K/(1+K)),2.0)+pow(c_a,2.0)*pow((tan(alpha_R)/(1+K)),2.0));

//     printf("gamma_F: %f, gamma_R: %f\n", gamma_F, gamma_R);

double Ff; 
if(gamma_F <= 3.0*mu*G_f) {
    Ff = 1.0 - (1.0/(3.0*mu*G_f))*(2.0-mu_s/mu)*gamma_F + (1.0/(9.0*pow(mu,2.0)*pow(G_f,2.0)))*(1.0-(2.0/3.0)*(mu_s/mu))*pow(gamma_F,2.0);
} else {
    Ff = mu_s*G_f/gamma_F;
}

double Fr; 
if(gamma_R <= 3.0*mu*G_r) {
    Fr = 1.0 - (1.0/(3.0*mu*G_r))*(2.0-mu_s/mu)*gamma_R + (1.0/(9.0*pow(mu,2.0)*pow(G_r,2.0)))*(1.0-(2.0/3.0)*(mu_s/mu))*pow(gamma_R,2.0);
} else {
    Fr = mu_s*G_r/gamma_R;
}

double Fyf = -c_a * tan(alpha_F) * Ff;
double Fxr = c_x * (K/(1.0+K)) * Fr * reverse;
double Fyr = -c_a * (tan(alpha_R)/(1.0+K)) * Fr;

double dr = (a*Fyf*cos(steer)-b*Fyr)/Iz;
double dUx = (Fxr-Fyf*sin(steer))/m+r*Uy;
double dUy = (Fyf*cos(steer)+Fyr)/m-r*Ux;